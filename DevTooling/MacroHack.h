#define SLASH /
#define SLASH2 SLASH/
#define SLASH3 SLASH2/
#define AUTOGENERATED_HEADER SLASH3 <auto-generated>This code was generated by the C Preprocessor. Do not modify this file, as any changes will be overwritten on the next build.</auto-generated>

// LMFAO ^^

// This is a prank. You are being pranked.

// This is a hilariously terrible hack that allows me to use C macros in C#
// Yes, it's terrible, and no, I don't care (that's why I did it anyway).

// Cope, seethe, and mald simultaneously.

#if !defined(ERROR_TRACK_BLOCK_START) && !defined(ERROR_TRACK_BLOCK_END)
	#ifdef DEBUG
		#define ERROR_TRACK_BLOCK_START try {
		#define ERROR_TRACK_BLOCK_END } catch (Exception ____err) { Log.LogError(____err); throw; }
	#else
		#define ERROR_TRACK_BLOCK_START {
		#define ERROR_TRACK_BLOCK_END }
	#endif
#endif

#if defined(REQUIRES_HARMONY_ARGS_PATCH) && !defined(DECLARED_HARMONY_ARGS_PATCH)
	#define DECLARED_HARMONY_ARGS_PATCH
	
	//////////////////////////////////

	#define DECLARE_HARMONY_PATCH_METHOD_HEAD(n, ...) [CPreprocessorGenerated] \
		private static bool AbstractReturningInjection##n##<TReturn, TInheritingType>(object __instance, MethodBase __originalMethod, ref TReturn __result, ##__VA_ARGS__)
	#define DECLARE_HARMONY_PATCH_METHOD_BASE(n, ARGSTYPED, ...) DECLARE_HARMONY_PATCH_METHOD_HEAD(n, ARGSTYPED) => AbstractReturningInjectionAny<TReturn, TInheritingType>(__instance, __originalMethod, ref __result, ##__VA_ARGS__##)
	
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_HEAD(n, ...) [CPreprocessorGenerated] \
		private static bool AbstractVoidInjection##n##<TInheritingType>(object __instance, MethodBase __originalMethod, ##__VA_ARGS__)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(n, ARGSTYPED, ...) DECLARE_HARMONY_PATCH_VOID_METHOD_HEAD(n, ARGSTYPED) => AbstractVoidInjectionAny<TInheritingType>(__instance, __originalMethod, ##__VA_ARGS__##)

	//////////////////////////////////

	#define OARGN(n) object __##n

	#define OARG0 OARGN(0)
	#define ARG0 __0

	#define OARG1 OARG0, OARGN(1)
	#define ARG1 ARG0, __1

	#define OARG2 OARG1, OARGN(2)
	#define ARG2 ARG1, __2

	#define OARG2 OARG1, OARGN(2)
	#define ARG2 ARG1, __2

	#define OARG3 OARG2, OARGN(3)
	#define ARG3 ARG2, __3

	#define OARG4 OARG3, OARGN(4)
	#define ARG4 ARG3, __4

	#define OARG5 OARG4, OARGN(5)
	#define ARG5 ARG4, __5

	#define OARG6 OARG5, OARGN(6)
	#define ARG6 ARG5, __6

	#define OARG7 OARG6, OARGN(7)
	#define ARG7 ARG6, __7

	#define OARG8 OARG7, OARGN(8)
	#define ARG8 ARG7, __8

	#define OARG9 OARG8, OARGN(9)
	#define ARG9 ARG8, __9

	#define OARG10 OARG9, OARGN(10)
	#define ARG10 ARG9, __10
	
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_NULL DECLARE_HARMONY_PATCH_METHOD_BASE(0,,)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_0 DECLARE_HARMONY_PATCH_METHOD_BASE(1,OARG0,ARG0)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_1 DECLARE_HARMONY_PATCH_METHOD_BASE(2,OARG1,ARG1)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_2 DECLARE_HARMONY_PATCH_METHOD_BASE(3,OARG2,ARG2)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_3 DECLARE_HARMONY_PATCH_METHOD_BASE(4,OARG3,ARG3)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_4 DECLARE_HARMONY_PATCH_METHOD_BASE(5,OARG4,ARG4)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_5 DECLARE_HARMONY_PATCH_METHOD_BASE(6,OARG5,ARG5)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_6 DECLARE_HARMONY_PATCH_METHOD_BASE(7,OARG6,ARG6)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_7 DECLARE_HARMONY_PATCH_METHOD_BASE(8,OARG7,ARG7)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_8 DECLARE_HARMONY_PATCH_METHOD_BASE(9,OARG8,ARG8)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_9 DECLARE_HARMONY_PATCH_METHOD_BASE(10,OARG9,ARG9)
	#define DECLARE_HARMONY_PATCH_METHOD_METHOD_10 DECLARE_HARMONY_PATCH_METHOD_BASE(11,OARG10,ARG10)

	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_NULL DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(0,,)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_0 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(1,OARG0,ARG0)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_1 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(2,OARG1,ARG1)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_2 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(3,OARG2,ARG2)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_3 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(4,OARG3,ARG3)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_4 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(5,OARG4,ARG4)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_5 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(6,OARG5,ARG5)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_6 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(7,OARG6,ARG6)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_7 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(8,OARG7,ARG7)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_8 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(9,OARG8,ARG8)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_9 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(10,OARG9,ARG9)
	#define DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_10 DECLARE_HARMONY_PATCH_VOID_METHOD_BASE(11,OARG10,ARG10)

	#define DECLARE_ALL_HARMONY_RETURNING_PATCH_METHODS DECLARE_HARMONY_PATCH_METHOD_METHOD_NULL; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_0; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_1; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_2; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_3; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_4; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_5; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_6; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_7; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_8; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_9; \
		DECLARE_HARMONY_PATCH_METHOD_METHOD_10

	#define DECLARE_ALL_HARMONY_VOID_PATCH_METHODS DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_NULL; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_0; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_1; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_2; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_3; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_4; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_5; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_6; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_7; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_8; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_9; \
		DECLARE_HARMONY_PATCH_VOID_METHOD_METHOD_10

	#define DECLARE_ALL_HARMONY_PATCH_METHODS DECLARE_ALL_HARMONY_RETURNING_PATCH_METHODS; \
		DECLARE_ALL_HARMONY_VOID_PATCH_METHODS
#endif

#ifndef __PROPERTY_MIRROR_HACKS__
#define __PROPERTY_MIRROR_HACKS__

// #define CREATE_BYREFS


#define SINGLE_ARG(...) __VA_ARGS__
#define GET_PROPERTY(propCtr, type, propName)		\
[CPreprocessorGenerated]							\
public type propName => propCtr.propName;

#define MIRROR_PROPERTY(propCtr, type, propName)	\
[CPreprocessorGenerated]							\
public type propName {								\
	get => propCtr.propName;						\
	set => propCtr.propName = value;				\
}

#ifdef CREATE_BYREFS
#define REF_GET_PROPERTY(propCtr, type, propName)	\
[CPreprocessorGenerated]							\
public type propName => propCtr.propName;			\
[CPreprocessorGenerated]							\
public ref type BYREF_##propName => ref propCtr.propName;

#define REF_MIRROR_PROPERTY(propCtr, type, propName)	\
[CPreprocessorGenerated]								\
public type propName {									\
	get => propCtr.propName;							\
	set => propCtr.propName = value;					\
}														\
[CPreprocessorGenerated]								\
public ref type BYREF_##propName => ref propCtr.propName;
#else
#define REF_GET_PROPERTY(propCtr, type, propName) GET_PROPERTY(propCtr, type, propName)
#define REF_MIRROR_PROPERTY(propCtr, type, propName) MIRROR_PROPERTY(propCtr, type, propName)
#endif

#define ALL_UPDATABLEANDDELETABLE_MIRROR_PROPERTIES(propCtr)	\
MIRROR_PROPERTY(propCtr, bool, slatedForDeletetion)				\
MIRROR_PROPERTY(propCtr, bool, evenUpdate)						\
MIRROR_PROPERTY(propCtr, Room, room)						

#define ALL_GRAPHICSMODULE_PROPERTIES(propCtr)					\
MIRROR_PROPERTY(propCtr, PhysicalObject, owner)					\
MIRROR_PROPERTY(propCtr, BodyPart[], bodyParts)					\
GET_PROPERTY(propCtr, bool, ShouldBeCulled)						\
MIRROR_PROPERTY(propCtr, bool, culled)							\
MIRROR_PROPERTY(propCtr, float, cullRange)						\
MIRROR_PROPERTY(propCtr, DebugLabel[], DEBUGLABELS)				\
MIRROR_PROPERTY(propCtr, bool, dispose)							\
MIRROR_PROPERTY(propCtr, bool, lastCulled)						\
MIRROR_PROPERTY(propCtr, List<GraphicsModule.ObjectHeldInInternalContainer>, internalContainerObjects)

#define ALL_PHYSICALOBJECT_MIRROR_PROPERTIES(propCtr)			\
MIRROR_PROPERTY(propCtr, float, airFriction)					\
MIRROR_PROPERTY(propCtr, BodyChunk[], bodyChunks)				\
MIRROR_PROPERTY(propCtr, float, buoyancy)						\
MIRROR_PROPERTY(propCtr, bool, CollideWithObjects)				\
MIRROR_PROPERTY(propCtr, bool, CollideWithSlopes)				\
MIRROR_PROPERTY(propCtr, bool, CollideWithTerrain)				\
GET_PROPERTY(propCtr, float, EffectiveRoomGravity)				\
GET_PROPERTY(propCtr, BodyChunk, firstChunk)					\
MIRROR_PROPERTY(propCtr, bool, GoThroughFloors)					\
MIRROR_PROPERTY(propCtr, GraphicsModule, graphicsModule)		\
MIRROR_PROPERTY(propCtr, float, gravity)						\
GET_PROPERTY(propCtr, Player, LickedByPlayer)					\
GET_PROPERTY(propCtr, BodyChunk, RandomChunk)					\
GET_PROPERTY(propCtr, float, Submersion)						\
GET_PROPERTY(propCtr, float, TotalMass)							\
GET_PROPERTY(propCtr, float, VisibilityBonus)					\
MIRROR_PROPERTY(propCtr, float, waterFriction)					\
MIRROR_PROPERTY(propCtr, AbstractPhysicalObject, abstractPhysicalObject)				\
MIRROR_PROPERTY(propCtr, List<PhysicalObject.Appendage>, appendages)					\
MIRROR_PROPERTY(propCtr, PhysicalObject.BodyChunkConnection[], bodyChunkConnections)	\
MIRROR_PROPERTY(propCtr, float, bounce)							\
MIRROR_PROPERTY(propCtr, bool, canBeHitByWeapons)				\
MIRROR_PROPERTY(propCtr, int, collisionLayer)					\
MIRROR_PROPERTY(propCtr, float, collisionRange)					\
MIRROR_PROPERTY(propCtr, float, g)								\
MIRROR_PROPERTY(propCtr, List<Creature.Grasp>, grabbedBy)		\
MIRROR_PROPERTY(propCtr, float, impactTreshhold)				\
MIRROR_PROPERTY(propCtr, int, jollyBeingPointedCounter)			\
MIRROR_PROPERTY(propCtr, bool, sticksRespawned)					\
MIRROR_PROPERTY(propCtr, float, surfaceFriction)				\
MIRROR_PROPERTY(propCtr, float, waterRetardationImmunity)

#define ALL_ORACLE_MIRROR_PROPERTIES(propCtr)					\
MIRROR_PROPERTY(propCtr, Oracle.OracleArm, arm)					\
MIRROR_PROPERTY(propCtr, int, behaviorTime)						\
MIRROR_PROPERTY(propCtr, float, dazed)							\
MIRROR_PROPERTY(propCtr, int, glowers)							\
MIRROR_PROPERTY(propCtr, float, health)							\
MIRROR_PROPERTY(propCtr, Oracle.OracleID, ID)					\
MIRROR_PROPERTY(propCtr, bool, marbleOrbiting)					\
MIRROR_PROPERTY(propCtr, List<PebblesPearl>, marbles)			\
MIRROR_PROPERTY(propCtr, LightSource, MoonLight)				\
MIRROR_PROPERTY(propCtr, OracleProjectionScreen, myScreen)		\
MIRROR_PROPERTY(propCtr, List<OracleSwarmer>, mySwarmers)		\
MIRROR_PROPERTY(propCtr, float, noiseSuppress)					\
MIRROR_PROPERTY(propCtr, OracleBehavior, oracleBehavior)		\
MIRROR_PROPERTY(propCtr, int, pearlCounter)						\
MIRROR_PROPERTY(propCtr, int, spasms)							\
MIRROR_PROPERTY(propCtr, StarMatrix, starMatrix)				\
MIRROR_PROPERTY(propCtr, int, stun)								\
MIRROR_PROPERTY(propCtr, bool, suppressConnectionFires)

#define ALL_ORACLEGRAPHICS_MIRROR_PROPERTIES(propCtr)			\
MIRROR_PROPERTY(propCtr, float[], voiceFreqSamples)				\
REF_MIRROR_PROPERTY(propCtr, int, totalSprites)						\
REF_MIRROR_PROPERTY(propCtr, int, firstHeadSprite)					\
REF_MIRROR_PROPERTY(propCtr, int, firstFootSprite)					\
REF_MIRROR_PROPERTY(propCtr, int, firstHandSprite)					\
REF_MIRROR_PROPERTY(propCtr, int, firstUmbilicalSprite)				\
REF_MIRROR_PROPERTY(propCtr, int, firstArmBaseSprite)				\
REF_MIRROR_PROPERTY(propCtr, int, fadeSprite)						\
REF_MIRROR_PROPERTY(propCtr, int, neckSprite)						\
REF_MIRROR_PROPERTY(propCtr, int, robeSprite)						\
REF_MIRROR_PROPERTY(propCtr, float, eyesOpen)						\
REF_MIRROR_PROPERTY(propCtr, float, lastEyesOpen)					\
REF_MIRROR_PROPERTY(propCtr, int, firstBodyChunkSprite)				\
REF_MIRROR_PROPERTY(propCtr, float, breathFac)						\
REF_MIRROR_PROPERTY(propCtr, float, lastBreatheFac)					\
MIRROR_PROPERTY(propCtr, Vector2, lastLookDir)					\
MIRROR_PROPERTY(propCtr, Vector2, lookDir)						\
MIRROR_PROPERTY(propCtr, GenericBodyPart, head)					\
MIRROR_PROPERTY(propCtr, GenericBodyPart[], hands)				\
MIRROR_PROPERTY(propCtr, GenericBodyPart[], feet)				\
MIRROR_PROPERTY(propCtr, SINGLE_ARG(Vector2[, ]), knees)		\
MIRROR_PROPERTY(propCtr, OracleGraphics.Gown, gown)				\
MIRROR_PROPERTY(propCtr, OracleGraphics.ArmJointGraphics[], armJointGraphics)					\
MIRROR_PROPERTY(propCtr, OracleGraphics.UbilicalCord, umbCord)	\
MIRROR_PROPERTY(propCtr, OracleGraphics.ArmBase, armBase)		\
MIRROR_PROPERTY(propCtr, OracleGraphics.Halo, halo)				\
MIRROR_PROPERTY(propCtr, Color, SLArmBaseColA)					\
MIRROR_PROPERTY(propCtr, Color, SLArmBaseColB)					\
MIRROR_PROPERTY(propCtr, Color, SLArmHighLightColA)				\
MIRROR_PROPERTY(propCtr, Color, SLArmHighLightColB)

#endif